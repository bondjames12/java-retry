{"name":"Enterprise Retry 4J","tagline":"Lets developers make their applications more resilient by adding robust transient fault handling logic.","body":"# NuoDB Practices\r\n\r\n[<img src=\"https://travis-ci.org/rbuck/enterprise-retry-4j.svg?branch=master\" alt=\"Build Status\" />](http://travis-ci.org/rbuck/enterprise-retry-4j)\r\n\r\nLets developers make their applications more resilient by adding robust\r\ntransient fault handling logic. Transient faults are errors that occur\r\nbecause of some temporary condition such as network connectivity issues\r\nor service unavailability. Typically, if you retry the operation that\r\nresulted in a transient error a short time later, you find that the\r\nerror has disappeared.\r\n\r\n## Retry\r\n\r\nInfrastructure exists to facilitate automatic transaction retry, and exception\r\ndetectors are written to properly handle a variety of SQLException types, so that\r\nretry occurs during transient exceptions, not others.\r\n\r\nRetry has been implemented in a generic fashion so as to be pluggable in a number\r\nof other non-SQL enterprise scenarios; so long as an exception detector is\r\nappropriately written, business level activities can be written in a fault\r\ntolerant manner.\r\n\r\n### Generic Retry Example\r\n\r\nHere is an example of your basic non-SQL retry loop:\r\n\r\n```java\r\n// the detector may optionally be a singleton...\r\nTransientExceptionDetector detector = new TransientExceptionDetector() {\r\n    @Override\r\n    public boolean isTransient(Exception e) {\r\n        // check exception type or content...\r\n    }\r\n};\r\n// the retry policy and strategies are allocated per transaction\r\n// and cannot be singletons, are typed...\r\nRetryPolicy<Integer> retryPolicy = new RetryPolicy<>(new ExponentialBackoff(), detector);\r\nint result = 0;\r\ntry {\r\n    result = retryPolicy.action(new Callable<Integer>() {\r\n        @Override\r\n        public Integer call() throws Exception {\r\n            return 5;\r\n        }\r\n    });\r\n} catch (Exception e) {\r\n    // ... do something to handle or log ...\r\n}\r\n```\r\n\r\nThere are a few actors on stage here:\r\n\r\n- the transient exception detector (returns true if the exception is a transient)\r\n- the retry policy (consistently applied policy)\r\n- the retry strategy (provides pluggable retry behaviors)\r\n- the callable (the action to be executed with retry capabilities)\r\n\r\n### SQL Retry Example\r\n\r\nHere is an example of your basic SQL retry loop:\r\n\r\n```java\r\nSqlTransactionContext sqlTransactionContext = new ...\r\nSqlRetryPolicy<Integer> sqlRetryPolicy = new SqlRetryPolicy<>(\r\n    new FixedInterval(1, 100), sqlTransactionContext);\r\ntry {\r\n    result = sqlRetryPolicy.action(new SqlCallable<Integer>() {\r\n        @Override\r\n        public Integer call(Connection connection) throws SQLException {\r\n            int result = ... from SQL result set ...\r\n            // critical: make sure to use try-with-resources to\r\n            // properly close all statements and result sets! \r\n            return result;\r\n        }\r\n    });\r\n} catch (Exception e) {\r\n    // ... do something to handle or log ... \r\n}\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}