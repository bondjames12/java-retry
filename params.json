{"name":"Enterprise Retry 4J","tagline":"Lets developers make their applications more resilient by adding robust transient fault handling logic.","body":"# Java Retry\r\n\r\n[![Maven Central](https://maven-badges.herokuapp.com/maven-central/com.github.rbuck/java-retry/badge.svg)](https://maven-badges.herokuapp.com/maven-central/com.github.rbuck/java-retry)\r\n\r\n[<img src=\"https://travis-ci.org/rbuck/java-retry.svg?branch=master\" alt=\"Build Status\" />](http://travis-ci.org/rbuck/java-retry)\r\n\r\nLets developers make their applications more resilient by adding robust\r\ntransient fault handling logic. Transient faults are errors that occur\r\nbecause of some temporary condition such as network connectivity issues\r\nor service unavailability. Typically, if you retry the operation that\r\nresulted in a transient error a short time later, you find that the\r\nerror has disappeared.\r\n\r\n## Retry\r\n\r\nInfrastructure exists to facilitate automatic transaction retry, and exception\r\ndetectors are written to properly handle a variety of SQLException types, so that\r\nretry occurs during transient exceptions, not others.\r\n\r\nRetry has been implemented in a generic fashion so as to be pluggable in a number\r\nof other non-SQL enterprise scenarios; so long as an exception detector is\r\nappropriately written, business level activities can be written in a fault\r\ntolerant manner.\r\n\r\n### Generic Retry Example\r\n\r\nHere is an example of your basic non-SQL retry loop:\r\n\r\n```java\r\n// the detector may optionally be a singleton...\r\nTransientExceptionDetector detector = new TransientExceptionDetector() {\r\n    @Override\r\n    public boolean isTransient(Exception e) {\r\n        // check exception type or content...\r\n    }\r\n};\r\n// the retry policy and strategies may be allocated as singletons\r\nRetryPolicy<Integer> retryPolicy = new RetryPolicy<>(new ExponentialBackoff(), detector);\r\nint result = 0;\r\ntry {\r\n    result = retryPolicy.action(new Callable<Integer>() {\r\n        @Override\r\n        public Integer call() throws Exception {\r\n            return 5;\r\n        }\r\n    });\r\n} catch (Exception e) {\r\n    // ... do something to handle or log ...\r\n}\r\n```\r\n\r\nThere are a few actors on stage here:\r\n\r\n- the transient exception detector (returns true if the exception is a transient)\r\n- the retry policy (consistently applied policy)\r\n- the retry strategy (provides pluggable retry behaviors)\r\n- the callable (the action to be executed with retry capabilities)\r\n\r\n### SQL Retry Example\r\n\r\nHere is an example of your basic SQL retry loop:\r\n\r\n```java\r\nSqlTransactionContext sqlTransactionContext = new ...\r\nSqlRetryPolicy<Integer> sqlRetryPolicy = new SqlRetryPolicy<>(\r\n    new FixedInterval(1, 100), sqlTransactionContext);\r\ntry {\r\n    result = sqlRetryPolicy.action(new SqlCallable<Integer>() {\r\n        @Override\r\n        public Integer call(Connection connection) throws SQLException {\r\n            int result = ... from SQL result set ...\r\n            // critical: make sure to use try-with-resources to\r\n            // properly close all statements and result sets! \r\n            return result;\r\n        }\r\n    });\r\n} catch (Exception e) {\r\n    // ... do something to handle or log ... \r\n}\r\n```\r\n\r\n### Spring Integration\r\n\r\nThe following Spring Bean definition snippet was used in a Mule ESB\r\nflow to enforce comprehensive resiliency for a subscriptions service.\r\nThe Spring Beans may be declared as singletons, and the code is thread\r\nsafe.\r\n\r\n```xml\r\n<spring:beans>\r\n    <spring:bean id=\"hikariConfig\" class=\"com.zaxxer.hikari.HikariConfig\">\r\n        <spring:property name=\"driverClassName\" value=\"com.nuodb.jdbc.Driver\" />\r\n        <spring:property name=\"jdbcUrl\"\r\n            value=\"jdbc:com.nuodb://localhost/subscribers?schema=subs\" />\r\n        <spring:property name=\"username\" value=\"dba\" />\r\n        <spring:property name=\"password\" value=\"dba\" />\r\n        <spring:property name=\"autoCommit\" value=\"true\" />\r\n        <spring:property name=\"readOnly\" value=\"false\" />\r\n        <spring:property name=\"connectionTestQuery\" value=\"SELECT 1 FROM DUAL\" />\r\n        <spring:property name=\"maximumPoolSize\" value=\"100\" />\r\n        <spring:property name=\"maxLifetime\" value=\"120000\" />\r\n        <spring:property name=\"isolateInternalQueries\" value=\"true\" />\r\n        <spring:property name=\"transactionIsolation\" value=\"TRANSACTION_READ_COMMITTED\" />\r\n    </spring:bean>\r\n\r\n    <spring:bean id=\"dataSource\" class=\"com.zaxxer.hikari.HikariDataSource\">\r\n        <spring:constructor-arg ref=\"hikariConfig\" />\r\n    </spring:bean>\r\n\r\n    <!--\r\n    Wraps a connection provider, in this case simply a DataSource.\r\n    -->\r\n    <spring:bean id=\"transactionContext\"\r\n        class=\"com.github.rbuck.retry.BasicSqlTransactionContext\">\r\n        <spring:constructor-arg ref=\"dataSource\" />\r\n    </spring:bean>\r\n\r\n    <!--\r\n    Default of 10 retries at most, binary exponential back-off,\r\n    starts at 1 second, progresses to 10 seconds each. \r\n    -->\r\n    <spring:bean id=\"retryStrategy\"\r\n        class=\"com.github.rbuck.retry.ExponentialBackoff\" />\r\n\r\n    <!-- \r\n    The retry policy implements the retry strategy for SQL transactions\r\n    within the subscriptions service.\r\n    -->\r\n    <spring:bean id=\"sqlRetryPolicy\"\r\n        class=\"com.github.rbuck.retry.SqlRetryPolicy\">\r\n        <spring:constructor-arg ref=\"retryStrategy\" />\r\n        <spring:constructor-arg ref=\"transactionContext\" />\r\n    </spring:bean>\r\n\r\n    <spring:bean id=\"SubscriberBean\" class=\"com.nuodb.samples.mule.SubscriberImpl\">\r\n        <spring:property name=\"retryPolicy\">\r\n            <spring:ref local=\"sqlRetryPolicy\" />\r\n        </spring:property>\r\n    </spring:bean>\r\n</spring:beans>\r\n```\r\n\r\nThen the corresponding Java code is simply:\r\n\r\n```java\r\n...\r\nreturn retryPolicy.action(new SqlCallable<String>() {\r\n    @Override\r\n    public String call(Connection connection) throws SQLException {\r\n        try (PreparedStatement preparedStatement = connection\r\n                .prepareStatement(sql)) {\r\n            try (ResultSet resultSet = preparedStatement.executeQuery()) {\r\n                return getResultAsJson(resultSet);\r\n            } catch (IOException e) {\r\n                throw new SQLNonTransientException(e);\r\n            }\r\n        }\r\n    }\r\n});\r\n...\r\n```\r\n\r\n## Building and Releasing\r\n\r\nTo compile and test the project issue the following commands:\r\n\r\n    mvn clean install\r\n\r\nTo release the project issue the following commands:\r\n\r\n    mvn release:clean\r\n    mvn release:prepare\r\n    mvn release:perform\r\n\r\n## Linking\r\n\r\nThis project has been released to Maven Central; to use it simply include this\r\nin your Maven POM file:\r\n\r\n    <dependency>\r\n        <groupId>com.github.rbuck</groupId>\r\n        <artifactId>java-retry</artifactId>\r\n        <version>1.1</version>\r\n        <scope>compile</scope>\r\n    </dependency>\r\n\r\n## License\r\n\r\nThis project is Apache 2.0 licensed.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}